import { GoogleGenAI, Modality } from "@google/genai";
import type { Base64Image } from "../types";

// Parse API keys from environment variable (comma-separated)
const API_KEYS_STRING = process.env.API_KEYS;

if (!API_KEYS_STRING) {
  throw new Error("API_KEYS environment variable not set");
}

const API_KEYS = API_KEYS_STRING.split(',').map(key => key.trim()).filter(key => key.length > 0);

if (API_KEYS.length === 0) {
  throw new Error("No valid API keys found in API_KEYS environment variable");
}

console.log(`Initialized with ${API_KEYS.length} API key(s)`);

// Track current key index for rotation
let currentKeyIndex = 0;

// Get next API key in rotation
function getNextApiKey(): string {
  const key = API_KEYS[currentKeyIndex];
  currentKeyIndex = (currentKeyIndex + 1) % API_KEYS.length;
  return key;
}

// Check if error is a rate limit/quota error
function isRateLimitError(error: unknown): boolean {
  if (!(error instanceof Error)) return false;
  const errorMsg = error.message.toLowerCase();
  return (
    errorMsg.includes('resource_exhausted') ||
    errorMsg.includes('429') ||
    errorMsg.includes('quota') ||
    errorMsg.includes('rate limit')
  );
}

// Check if error is a timeout or connection error
function isTimeoutError(error: unknown): boolean {
  if (!(error instanceof Error)) return false;
  const errorMsg = error.message.toLowerCase();
  return (
    errorMsg.includes('timeout') ||
    errorMsg.includes('connection') ||
    errorMsg.includes('network')
  );
}

export async function generateAdImage(
  logoImage: Base64Image,
  prompt: string
): Promise<string> {
  const model = 'gemini-2.5-flash-image';
  let lastError: Error | null = null;
  
  // Try with all available API keys before giving up
  for (let attempt = 0; attempt < API_KEYS.length; attempt++) {
    try {
      const apiKey = getNextApiKey();
      const ai = new GoogleGenAI({ apiKey });
      
      // Create a timeout promise
      const timeout = new Promise((_, reject) => 
        setTimeout(() => reject(new Error('Request timeout after 60 seconds')), 60000)
      );
      
      // Race between API call and timeout
      const responsePromise = ai.models.generateContent({
        model: model,
        contents: {
          parts: [
            { inlineData: { mimeType: logoImage.mimeType, data: logoImage.base64 } },
            { text: prompt },
          ],
        },
        config: {
          responseModalities: [Modality.IMAGE],
        },
      });
      
      const response = await Promise.race([responsePromise, timeout]) as any;

      for (const part of response.candidates[0].content.parts) {
        if (part.inlineData) {
          return `data:${part.inlineData.mimeType};base64,${part.inlineData.data}`;
        }
      }

      throw new Error("No image was generated by the API.");

    } catch (error) {
      lastError = error instanceof Error ? error : new Error(String(error));
      
      // If it's a rate limit or timeout error and we have more keys to try, continue to next key
      if ((isRateLimitError(error) || isTimeoutError(error)) && attempt < API_KEYS.length - 1) {
        const errorType = isRateLimitError(error) ? 'Rate limit' : 'Timeout';
        console.warn(`${errorType} hit on API key ${attempt + 1}/${API_KEYS.length}, trying next key...`);
        continue;
      }
      
      // For non-recoverable errors or last key, throw immediately
      console.error("Error generating ad image:", error);
      const errorMessage = error instanceof Error ? error.message : JSON.stringify(error);
      throw new Error(`Failed to generate image: ${errorMessage}`);
    }
  }
  
  // All keys exhausted
  throw new Error(`Failed to generate image after trying all ${API_KEYS.length} API key(s): ${lastError?.message}`);
}
